[{"title":"搬砖黑话整理","url":"/argots/","content":"\nPTAL: Please Take A Look, 摇人来 review\nLGTM: Looks Good To Me, 看起来不错\ncc: Carbon Copy, 抄送\nFYI: For Your Information, 供你参考\nTBD: To Be Determined/Done/…, 反正就是还没搞\nnuts: 本意是吹毛求疵，指无足轻重的小建议\nNO-OP: No Operation, 无需操作/什么都没改\n\n","categories":["杂项"]},{"title":"Hello World","url":"/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"新的开始","url":"/new-beginning/","content":"大约两年前曾经在阿里云用 WordPress 自己搭过一个博客，还搞了 https 和备案。可惜由于前些时间疏于维护，还是懒得继续了。\n最近又有重建博客的念头，但是各家学生机都买过一遍了，不想多花钱。GitHub Pages 就很好，至少是免费的，并且折腾一下也很好看。\n这段时间应该会断断续续把以前的博客搬运过来。没了。\n","categories":["杂项"]},{"title":"旧的不去，新的不来","url":"/farewell/","content":"试图搬运旧博客的时候悲痛发现没复制数据库，而 WordPress 的文件夹里又没有 cache，基本上可以宣告找不回来了。\n可惜终归是可惜的。不过本来就已经退役了，过去的事情不再提也罢。\n上次重建博客是 22 年 7 月，说来可笑，去年因为状态完全不在线，其实重建之后也没写过多少题。重建之前倒是发过几道还算可以的题，不过感觉也没有什么值得搬过来的，那暂且就这样吧。\nFarewell.\n","categories":["杂项"]},{"title":"ICPC2021昆明F Generating Strings","url":"/icpc2021-kunming-f-generating-strings/","content":"（搬运自旧博客）\n传送门\n对于  中每个回文串，设它的长度是 ，那么显然它对答案的贡献就是 ，因此只需要求出所有回文串的贡献即可。\n由于要支持尾部加减字符，不难想到要用回文树维护。但回文树只是一个均摊的数据结构，直接模拟复杂度肯定是错的，因此要离线一下，建出一个字典树，然后使用 广义回文树 维护。\n广义回文树的构造方法和广义 SAM 有些类似，但是要注意几个问题：\n\n构造回文树需要得知前面的字符来进行比较，也就是快速询问树上一个点的第  个祖先；使用长链剖分（这种用法也被称为梯子剖分）可以做到  预处理后  询问，比倍增要小大约一倍的常数。\n每次暴力跳失配指针复杂度肯定是错的，因此要使用类似AC自动机的思想，用一个 fail 数组直接维护对每个字符它会跳到哪里。\n回文树最好写成 last = 1，然后 fail[0] 和 fail[1] 都要初始化成 1。\n\n总复杂度 ，在牛客上最快也要 700+ms，有点勉强。\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int maxn = 1000005, mod = 1000000007;int val[maxn], par[maxn], go[maxn][26], fail[maxn][26], pam_last[maxn], pam_cnt;int weight[maxn], pow_26[maxn];int trie[maxn][26], trie_cnt, d[maxn], mxd[maxn], son[maxn], top[maxn], len[maxn], sum[maxn];char chr[maxn];int f[25][maxn], log_tbl[maxn];vector&lt;int&gt; v[maxn];vector&lt;int&gt; queries[maxn];char str[maxn];int n, m, ans[maxn];int add(int x, int c) {\tif (!trie[x][c]) {\t\ttrie[x][c] = ++trie_cnt;\t\tf[0][trie[x][c]] = x;\t\tchr[trie[x][c]] = c + 'a';\t}\t\treturn trie[x][c];}int del(int x) {\treturn f[0][x];}void dfs1(int x) {\tmxd[x] = d[x] = d[f[0][x]] + 1;\tfor (int i = 0; i &lt; 26; i++)\t\tif (trie[x][i]) {\t\t\tint y = trie[x][i];\t\t\tdfs1(y);\t\t\tmxd[x] = max(mxd[x], mxd[y]);\t\t\tif (mxd[y] &gt; mxd[son[x]])\t\t\t\tson[x] = y;\t\t}}void dfs2(int x) {\tif (x == son[f[0][x]])\t\ttop[x] = top[f[0][x]];\telse\t\ttop[x] = x;\t\tfor (int i = 0; i &lt; 26; i++)\t\tif (trie[x][i]) {\t\t\tint y = trie[x][i];\t\t\tdfs2(y);\t\t}\t\tif (top[x] == x) {\t\tint u = x;\t\twhile (top[son[u]] == x)\t\t\tu = son[u];\t\t\t\tlen[x] = d[u] - d[x];\t\tfor (int i = 0; i &lt; len[x]; i++) {\t\t\tv[x].push_back(u);\t\t\tu = f[0][u];\t\t}\t\tu = x;\t\tfor (int i = 0; i &lt; len[x]; i++) { // 梯子剖分，要延长一倍\t\t\tv[x].push_back(u);\t\t\tu = f[0][u];\t\t}\t}}int get_anc(int x, int k) {\tif (!k)\t\treturn x;\tif (k &gt; d[x])\t\treturn 0;\t\tx = f[log_tbl[k]][x];\tk ^= 1 &lt;&lt; log_tbl[k];\treturn v[top[x]][d[top[x]] + len[top[x]] - d[x] + k];}char get_char(int x, int k) { // 查询x前面k个的字符是哪个\treturn chr[get_anc(x, k)];}int getfail(int x, int p) {\tif (get_char(x, val[p] + 1) == chr[x])\t\treturn p;\treturn fail[p][chr[x] - 'a'];}int extend(int x) {\tint p = pam_last[f[0][x]], c = chr[x] - 'a';\tp = getfail(x, p);\tint new_last;\t\tif (!go[p][c]) {\t\tint q = ++pam_cnt, now = p;\t\tval[q] = val[p] + 2;\t\tp = getfail(x, par[p]);\t\tpar[q] = go[p][c];\t\tnew_last = go[now][c] = q;\t\t\t\tfor (int i = 0; i &lt; 26; i++)\t\t\tfail[q][i] = fail[par[q]][i];\t\t\t\tif (get_char(x, val[par[q]]) &gt;= 'a')\t\t\tfail[q][get_char(x, val[par[q]]) - 'a'] = par[q];\t\t\t\tif (val[q] &lt;= n)\t\t\tweight[q] = (weight[par[q]] + (long long)(n - val[q] + 1) * pow_26[n - val[q]]) % mod;\t\telse\t\t\tweight[q] = weight[par[q]];\t}\telse\t\tnew_last = go[p][c];\t\tpam_last[x] = new_last;\treturn weight[pam_last[x]];}void bfs() {\tqueue&lt;int&gt; q;\tq.push(1);\twhile (!q.empty()) {\t\tint x = q.front();\t\tq.pop();\t\tsum[x] = sum[f[0][x]];\t\tif (x &gt; 1)\t\t\tsum[x] = (sum[x] + extend(x)) % mod;\t\t\t\t\tfor (int i : queries[x])\t\t\tans[i] = sum[x];\t\t\t\tfor (int i = 0; i &lt; 26; i++)\t\t\tif (trie[x][i])\t\t\t\tq.push(trie[x][i]);\t}\t}int main() {\tpow_26[0] = 1;\tlog_tbl[0] = -1;\tfor (int i = 1; i &lt;= 1000000; i++) {\t\tpow_26[i] = 26ll * pow_26[i - 1] % mod;\t\tlog_tbl[i] = log_tbl[i / 2] + 1;\t}\tint T;\tscanf(\"%d\", &amp;T);\twhile (T--) {\t\tscanf(\"%d%d%s\", &amp;n, &amp;m, str);\t\ttrie_cnt = 1;\t\tchr[1] = '#';\t\tint last = 1;\t\tfor (char *c = str; *c; c++)\t\t\tlast = add(last, *c - 'a');\t\t\t\tqueries[last].push_back(0);\t\t\t\tfor (int i = 1; i &lt;= m; i++) {\t\t\tint op;\t\t\tscanf(\"%d\", &amp;op);\t\t\t\t\t\tif (op == 1) {\t\t\t\tchar c;\t\t\t\tscanf(\" %c\", &amp;c);\t\t\t\tlast = add(last, c - 'a');\t\t\t}\t\t\telse\t\t\t\tlast = del(last);\t\t\t\t\t\tqueries[last].push_back(i);\t\t}\t\tdfs1(1);\t\tdfs2(1);\t\tfor (int j = 1; j &lt;= log_tbl[trie_cnt]; j++)\t\t\tfor (int i = 1; i &lt;= trie_cnt; i++)\t\t\t\tf[j][i] = f[j - 1][f[j - 1][i]];\t\t\t\tpar[0] = pam_cnt = 1;\t\t\t\t\t\tfor (int i = 0; i &lt; 26; i++)\t\t\tfail[0][i] = fail[1][i] = 1;\t\t\t\tval[1] = -1;\t\tpam_last[1] = 1;\t\tbfs();\t\tfor (int i = 0; i &lt;= m; i++)\t\t\tprintf(\"%d\\n\", ans[i]);\t\t\t\tfor (int j = 0; j &lt;= log_tbl[trie_cnt]; j++)\t\t\tmemset(f[j], 0, sizeof(f[j]));\t\tfor (int i = 1; i &lt;= trie_cnt; i++) {\t\t\tchr[i] = 0;\t\t\td[i] = mxd[i] = son[i] = top[i] = len[i] = pam_last[i] = sum[i] = 0;\t\t\tv[i].clear();\t\t\tqueries[i].clear();\t\t\tmemset(trie[i], 0, sizeof(trie[i]));\t\t}\t\ttrie_cnt = 0;\t\tfor (int i = 0; i &lt;= pam_cnt; i++) {\t\t\tval[i] = par[i] = weight[i];\t\t\tmemset(go[i], 0, sizeof(go[i]));\t\t\tmemset(fail[i], 0, sizeof(fail[i]));\t\t}\t\tpam_cnt = 0;\t}\treturn 0;}\n\n注：如果字符集比较大就要用可持久化线段树维护，码量会进一步提升…\n","categories":["题解"],"tags":["字符串, 回文树"]}]